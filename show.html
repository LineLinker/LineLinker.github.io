<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Show</title>
	<link rel="stylesheet" href="css/nav.css">
	<link rel="stylesheet" href="css/body.css">
</head>
<body>
	<nav class="homenav nav" >
        <div class="navtitle"><strong>Yye</strong>|MY WORKS</div>
        <a href="Home.html">HOME</a>
        <a href="Search.html">SEARCH</a>
        <a href="Show.html">SHOW</a>
        <a href="Space.html">SPACE</a>
        <a href="Other.html">OTHER</a>
        <div class="navanim show"></div>
        <div class="none"></div>
    </nav>
	<div class="preloader" id="jiazai">
		<div class="counter" id="jishu">0</div>
	</div>
    <div class="scrollcon">
        <div class="wavy" id="1">
			<span style="--i:1;">向</span>
			<span style="--i:2;">&nbsp;下</span>
			<span style="--i:3;">&nbsp;轻</span>
			<span style="--i:4;">&nbsp;滑</span>
			<span style="--i:5;">&nbsp;一</span>
			<span style="--i:6;">&nbsp;下</span>
		</div>
     	<div class="wavy">
			<span style="--i:1;">R</span>
			<span style="--i:2;">&nbsp;e</span>
			<span style="--i:3;">&nbsp;a</span>
			<span style="--i:4;">&nbsp;d</span>
			<span style="--i:5;">&nbsp;y</span>
			<span style="--i:6;">&nbsp;?</span>
		</div>
		<div class="wavy">
			<span style="--i:1;">S</span>
			<span style="--i:2;">&nbsp;T</span>
			<span style="--i:3;">&nbsp;A</span>
			<span style="--i:4;">&nbsp;R</span>
			<span style="--i:5;">&nbsp;T</span>
			<span style="--i:6;">&nbsp;!</span>
		</div>
		<div class="wavy">
			<span style="--i:1;">代</span>
			<span style="--i:2;">&nbsp;码</span>
			<span style="--i:3;">&nbsp;雨</span>
		</div>
		<canvas id="canvas" style="scroll-snap-align: start;"></canvas>
		<div class="wavy">
			<span style="--i:1;">还</span>
			<span style="--i:2;">&nbsp;有</span>
			<span style="--i:3;">&nbsp;，</span>
			<span style="--i:4;">&nbsp;继</span>
			<span style="--i:5;">&nbsp;续</span>
			<span style="--i:6;">&nbsp;滑</span>
		</div>
		<div class="wavy">
			<span style="--i:1;">牛</span>
			<span style="--i:2;">&nbsp;顿</span>
			<span style="--i:3;">&nbsp;摇</span>
			<span style="--i:4;">&nbsp;篮</span>
		</div>
		<div class="niudunyaolan">
			<span></span>
			<span></span>
			<span></span>
			<span></span>
			<span></span>
		</div>
		<div class="wavy">
			<span style="--i:1;">没</span>
			<span style="--i:2;">&nbsp;有</span>
			<span style="--i:3;">&nbsp;啦</span>
		</div>
		<div class="wavy">
			<span style="--i:1;">真</span>
			<span style="--i:2;">&nbsp;的</span>
			<span style="--i:3;">&nbsp;没</span>
			<span style="--i:4;">&nbsp;有</span>
			<span style="--i:5;">&nbsp;啦</span>
		</div>
		<canvas id="canvas1" style="scroll-snap-align: start;"></canvas>
		<footer style="margin-top: 0px;scroll-snap-align: start;" class="foot">
			<p style="color:cyan;">都说了没有啦  &nbsp;&nbsp;&nbsp; <a href="#1">点我回顶部</a></p>
			<p>©Create By YYE</p>
		</footer>
	</div>
</body>
<style>
	/*导航栏额外效果*/
	.nav {
 	 	top: -75px; /* 初始状态隐藏在顶部 */
  		transition: top 0.5s; /* 添加过渡效果，top属性在0.5秒内变化 */
	}
	.nav-show {
  		top: 0; /* 添加一个类，用于显示导航栏 */
	}
	/*预加载动画相关*/
	.preloader{
		position: fixed;
		top:0;
		display: flex;
		justify-content: center;
		align-items: center;
		width: 100%;
		height: 100vh;
		background:#070707;
		z-index: 100000;
	}
	.preloader::before{
		content: 'loading...';
		position: absolute;
		font-size: 12em;
		font-weight: 900;
		text-transform: uppercase;
		color: rgba(255,255,255,0.03);
	}
	.preloader.active{
		transform: translateY(-100vh);
		transition: ease-in-out 2s;
		transition-delay: 1s;
	}
	/*计数器*/
	.counter{
		position: relative;
		color: #fff;
		font-size: 16em;
		font-weight: 700;
		z-index: 1;
	}
	.counter::after{
		content:'%';
		font-size: 0.5em;
	}
	/*隐藏*/
	.hide{
		opacity: 0;
		transition: 1s;
		pointer-events: none;
	}
	/*主体部分*/
	.scrollcon{
		scroll-snap-type: y mandatory;/*y方向强制对齐*/
    	overflow-x: hidden;
    	height: 100vh;
	}
	/*文字动画效果*/
	.wavy{
		width: 100%;
		height:750px;
    	scroll-snap-align: start;/*强制对齐*/
		background: #000;
		display: flex;
		/*水平、垂直居中*/
		justify-content: center;
		align-items: center;
		position: relative;
	}
	.wavy span{
		position: relative;
		display: inline-block;/*内联块级元素*/
		color: #fff;
		font-size: 10em;
		-webkit-background-clip: text;/*将背景图像应用于文本上*/
    	background-image:linear-gradient(90deg, #ff6b6b, #ffc5c5, #a3f7bf, #00bfff, #fc00ff);
    	background-size: 800%;
    	animation: animate 1s ease-in-out infinite calc(0.1s*var(--i)),gradient 20s infinite linear;
    	color: transparent;;/*文本颜色透明*/
	}
	/*文字跳动效果*/
	@keyframes animate{
		0%{
			transform: translateY(0px);
		}
		20%{
			transform: translateY(-20px);
		}
		40%,100%
		{
			transform:translateY(0px);
		}
	}
	/*文字颜色变效果*/
	@keyframes gradient{
    	100%{
        	background-position: -800% 0%;
    	}
	}
	/*牛顿摇篮*/
	.niudunyaolan{
			scroll-snap-align: start;
			width: 100%;
			height: 100%;
			margin-top:5px;
			border-top:4px solid #262626;
			border-bottom:40px solid #262626;
			border-left:1px solid #262626;
			border-right:1px solid #262626;
			display: flex;/*子元素flex布局*/
			padding:0 25% 20px;
	}
	.niudunyaolan span{
			position: relative;/*相对定位*/
			display: block;
			width: 8px;
			height: 600px;
			background: #262626;
			margin: 0 70px;
			transform-origin: top;/*变换原点为顶部*/
		}
	.niudunyaolan span:before{
			content: '';
			position: absolute;
			bottom: 0;
			left: -75px;
			width: 150px;
			height: 150px;
			background: #262626;
			border-radius: 50%;
		}
	/*让第一个 span 元素执行 animate1 动画*/
	.niudunyaolan span:first-child{
			animation: animate1 1s linear infinite;
		}
	/*让最后一个 span 元素执行 animate2 动画，并延迟 0.5s 执行*/
	.niudunyaolan span:last-child{
			animation: animate2 1s linear infinite;
			animation-delay: 0.5s;
		}
	@keyframes animate1 {
			0%{
				transform: rotate(0deg);
			}
			25%{
				transform: rotate(60deg);
			}
			50%{
				transform: rotate(0deg);
			}
			100%{
				transform: rotate(0deg);
			}
		}
	@keyframes animate2 {
			0%{
				transform: rotate(0deg);
			}
			25%{
				transform: rotate(-60deg);
			}
			50%{
				transform: rotate(0deg);
			}
			100%{
				transform: rotate(0deg);
			}
	}
</style>
<script type="text/javascript">
/*导航栏自动隐藏效果*/
var nav = document.querySelector(".nav"); // 获取导航栏元素
var timer = null; // 定义一个定时器变量
var lastScrollTop = 0; // 定义一个变量，用于记录上一次的滚动位置
var showFlag = false; // 定义一个标志变量，用于记录导航栏是否显示
//显示导航栏
function showNav() {
  nav.classList.add("nav-show"); // 给导航栏添加nav-show类，使其显示
  showFlag = true; // 设置标志变量为true
}
//隐藏导航栏
function hideNav() {
  nav.classList.remove("nav-show"); // 给导航栏移除nav-show类，使其隐藏
  showFlag = false; // 设置标志变量为false
}
//5秒后隐藏导航栏
function hideNavAfter5s() {
  clearTimeout(timer); // 清除之前的定时器，避免重复触发
  timer = setTimeout(hideNav, 5000); // 设置一个新的定时器，在5秒后执行hideNav函数
}
// 给window对象添加一个scroll事件，当页面滚动时执行以下代码
window.addEventListener("scroll", function () {
  var scrollTop = window.pageYOffset || document.documentElement.scrollTop; // 获取当前的滚动位置
  if (scrollTop > lastScrollTop) {
    // 如果当前的滚动位置大于上一次的滚动位置，说明向下滑动了
    hideNav(); // 隐藏导航栏
  }
  lastScrollTop = scrollTop; // 更新上一次的滚动位置为当前的滚动位置
});
// 给window对象添加一个mousemove事件，当鼠标移动时执行以下代码
window.addEventListener("mousemove", function (e) {
  var y = e.clientY; // 获取鼠标的纵坐标
  if (y <= 75 && !showFlag) {
    // 如果鼠标在导航栏区域内，并且导航栏没有显示
    showNav(); // 显示导航栏
    hideNavAfter5s(); // 在5秒后隐藏导航栏
  }
});
// 给导航栏添加一个mouseenter事件，当鼠标进入时执行以下代码
nav.addEventListener("mouseenter", function () {
  clearTimeout(timer); // 清除定时器，避免隐藏导航栏
});
// 给导航栏添加一个mouseleave事件，当鼠标离开时执行以下代码
nav.addEventListener("mouseleave", function () {
  hideNavAfter5s(); // 在5秒后隐藏导航栏
});

/*预加载动画计数器*/
function counter() {
    // 设置一个计时器，每10毫秒执行一次
    var count = setInterval(
        function () {
            // 获取显示计数的元素
            var counter = document.getElementById('jishu');
            // 将计数器的值转为数字并加1，再将其转为字符串显示
            var c = parseInt(counter.innerText);
            counter.innerText = (++c).toString();
            // 当计数器达到100时，停止计时器
            if (c == 100) {
                clearInterval(count);
                // 隐藏计数器并显示加载动画
                counter.classList.add('hide');
                document.getElementById('jiazai').classList.add('active');
            }
        },
        10);// 每次计时器执行的时间间隔，单位为毫秒
}
// 调用计数器函数，开始执行计数器
counter();

/*canvas代码雨绘画*/
// 获取 canvas 元素的宽度和高度,并将宽度和高度设置为屏幕的可用宽度和高度。
//const width = document.getElementById("canvas").width = screen.availWidth;
//const height = document.getElementById("canvas").height = screen.availHeight;
const width =canvas.width=1800;
const height =canvas.height=800;
// 获取 canvas 的绘图上下文
const ctx = document.getElementById("canvas").getContext("2d");
// 创建一个大小为 width/10 的数组并填充为 0
const arr = Array(Math.ceil(width / 10)).fill(0);
// 创建一个字符串数组,用于存储字符。
const str = "✧☹︎☠︎☸︎☣︎☢︎☯︎♾♲✰❤︎✦⚛︎☭☮︎⚔︎⚒︎☄︎✵⚰︎☘︎⚘♨︎✞☺︎♘♞☆☃︎★☼☀︎☾◎☽☁︎™Ω℞№ℹ︎❂❁✡︎✣✶✺✷◦◉⦿☒✗☐☞◇☛⚙︎☑︎⌘✘✔︎".split("");
ctx.font = "10px 微软雅黑";
function rain() {
	// 设置颜色，并绘制一个全屏的矩形
	ctx.fillStyle = "rgba(0,0,20,0.05)";
	ctx.fillRect(0, 0, width, height);
	// 设置文字的颜色
	ctx.fillStyle = '#00c8aa';
	arr.forEach(
		function (value, index) {
			// 根据数组的索引值来绘制文字，x 坐标为索引值 * 10，y 坐标为 value + 10。
			ctx.fillText(str[Math.floor(Math.random() * str.length)], index * 10, value + 10);
			// 从上一次绘制的位置开始，将数组值设置为下一次绘制位置。
			arr[index] = value >= height || value > 8888 * Math.random() ? 0 : value + 10;
		}
	);
}
// 每 30 毫秒执行一次 rain() 函数。
setInterval(rain, 30); 	

/*飘动的粒子*/
let canvas1 = document.getElementById("canvas1")
canvas1.width =1800
canvas1.height =800
let ctx1 = canvas1.getContext("2d")
let particles = []// 创建一个存储粒子对象的数组
let mouse = {// 定义一个鼠标对象
	// 初始x、y坐标
    x: -500,
    y: -500
}
// 监听鼠标移动事件
document.addEventListener("mousemove", function (evt) {
    // 更新鼠标的x、y坐标
    mouse.x = evt.x
    mouse.y = evt.y
})
class particle {// 定义粒子类
    constructor() {
        this.x = 0 // x坐标
        this.y = 0 // y坐标
        this.vx = 0 // x方向速度
        this.vy = 0 // y方向速度
        this.age = 0 // 年龄，即存在时间
        this.init() // 初始化粒子的属性
    }
    init() { // 初始化粒子的属性方法
        this.x = Math.random() * canvas1.width|0 // 随机生成x坐标
        this.y = Math.random() * canvas1.height|0 // 随机生成y坐标
        this.vx = Math.random() - 0.5 // 随机生成x方向速度
        this.vy = Math.random() - 0.5 // 随机生成y方向速度
        this.age = Math.random() * 50 | 0 // 随机生成年龄
    }
    update() { // 更新粒子状态的方法
        this.x += this.vx // 更新x坐标
        this.y += this.vy // 更新y坐标
        if (this.x < 0 || this.x > canvas1.width || this.y < 0 || this.y > canvas1.height) { // 判断是否超出画布范围
            this.init() // 如果超出范围，则重新生成一个新的粒子
        }
        this.age-- // 年龄减1
        if (this.age < 0) { // 如果年龄小于0
            this.age = Math.random() * 50 | 0 // 重新生成一个随机的年龄
            this.vx += (Math.random() - 0.5) * 0.1 // 在原有速度的基础上，加上一个小的随机速度
            this.vy += (Math.random() - 0.5) * 0.1 // 在原有速度的基础上，加上一个小的随机速度
        }
        // 计算粒子与鼠标的距离
        let r = Math.sqrt(Math.pow(this.x - mouse.x, 2) + Math.pow(this.y - mouse.y, 2))
        if (r < 200) {// 如果距离小于200
        	//将粒子向鼠标位置移动
            this.x -= (this.x - mouse.x) / 500
            this.y -= (this.y - mouse.y) / 500
        }
    }
    draw() {
    	// 开始新路径
    	ctx1.beginPath();
    	// 绘制一个圆形路径，圆心坐标为 (this.x, this.y)，半径为1，起始角度为0，终止角度为2π
    	ctx1.arc(this.x, this.y, 1, 0, Math.PI * 2);
    	// 填充当前路径
    	ctx1.fill();
	}
}
function init() {
	//生成粒子，200次
    for (let i = 0; i < 200; i++) {
        particles.push(new particle())
    }
}
init()
function ani() {
    ctx1.clearRect(0, 0, canvas1.width, canvas1.height)// 清空画布
    for (let i in particles) {// 遍历所有粒子
        let p = particles[i]
        p.update()// 更新粒子状态
        p.draw()// 绘制粒子
            for(let j=i;j<particles.length;j++){// 遍历除自身以外的所有粒子
            let p2 = particles[j]
            // 计算当前粒子与其他粒子之间的距离
            let r = Math.sqrt(Math.pow(p.x - p2.x, 2) + Math.pow(p.y - p2.y, 2))
            if (r < 50) {// 如果距离小于一定值
            	// 绘制连线
                ctx1.beginPath()
                ctx1.moveTo(p.x, p.y)
                ctx1.lineTo(p2.x, p2.y)
                ctx1.strokeStyle = "rgba(0,0,0," + (1 - r / 50) + ")"// 设置线条颜色和透明度
                ctx1.stroke()// 绘制线条
            }
        }
    }
}
setInterval(ani, 1000 / 60)//每秒钟被调用60次
</script>
</html>
